"""
Telegram –±–æ—Ç - –¢—Ä–µ–Ω–∞–∂–µ—Ä –ø–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—é
–í–µ—Ä—Å–∏—è: 1.5
–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞: aiogram 3.25.0
"""

# ========== –ò–ú–ü–û–†–¢–´ ==========
import logging
import sqlite3
from datetime import datetime
import asyncio
import ast
import sys
import io
import contextlib
import traceback
import re
import os
import json
import time
import random
import math
import subprocess
import tempfile
from typing import Dict, List, Any, Optional, Tuple, Union
from pathlib import Path
from collections import defaultdict
import shutil

# –ò–º–ø–æ—Ä—Ç—ã –∏–∑ aiogram
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.types import (
    ReplyKeyboardMarkup, KeyboardButton,
    InlineKeyboardMarkup, InlineKeyboardButton,
    Message, CallbackQuery
)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage

# ========== –ú–û–î–£–õ–¨ –ü–†–û–í–ï–†–ö–ò –ö–û–î–ê ==========
class CodeChecker:
    """–ö–ª–∞—Å—Å –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–¥–∞ –Ω–∞ —Ä–∞–∑–Ω—ã—Ö —è–∑—ã–∫–∞—Ö"""
    
    @staticmethod
    def check_python(code: str, function_name: str = None, test_cases: List[Dict] = None) -> Dict[str, Any]:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ Python –∫–æ–¥–∞"""
        try:
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞
            ast.parse(code)
            
            if not function_name or not test_cases:
                return {
                    'valid': True,
                    'language': 'python',
                    'message': '‚úÖ –°–∏–Ω—Ç–∞–∫—Å–∏—Å –≤–µ—Ä–Ω—ã–π'
                }
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ–º–∞–Ω—Ç–∏–∫–∏ —Å —Ç–µ—Å—Ç–∞–º–∏
            local_namespace = {}
            stdout_capture = io.StringIO()
            
            with contextlib.redirect_stdout(stdout_capture):
                exec(code, {'__builtins__': __builtins__}, local_namespace)
            
            if function_name not in local_namespace:
                return {
                    'passed': False,
                    'error': f'–§—É–Ω–∫—Ü–∏—è {function_name} –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞',
                    'test_results': [],
                    'passed_count': 0,
                    'total_count': len(test_cases)
                }
            
            user_function = local_namespace[function_name]
            test_results = []
            passed_count = 0
            
            for i, test in enumerate(test_cases, 1):
                try:
                    args = test['input']
                    expected = test['expected']
                    result = user_function(*args)
                    passed = (result == expected)
                    
                    if passed:
                        passed_count += 1
                    
                    test_results.append({
                        'test_id': i,
                        'input': args,
                        'expected': expected,
                        'actual': result,
                        'passed': passed,
                        'error': None
                    })
                    
                except Exception as e:
                    test_results.append({
                        'test_id': i,
                        'input': test['input'],
                        'expected': test['expected'],
                        'actual': None,
                        'passed': False,
                        'error': str(e)
                    })
            
            return {
                'passed': passed_count == len(test_cases),
                'test_results': test_results,
                'passed_count': passed_count,
                'total_count': len(test_cases),
                'output': stdout_capture.getvalue()
            }
            
        except SyntaxError as e:
            return {
                'valid': False,
                'error': str(e),
                'line': e.lineno,
                'message': f'‚ùå –û—à–∏–±–∫–∞ –≤ —Å—Ç—Ä–æ–∫–µ {e.lineno}: {e.msg}'
            }
        except Exception as e:
            return {
                'valid': False,
                'error': str(e),
                'message': f'‚ùå –û—à–∏–±–∫–∞: {str(e)}'
            }
    
    @staticmethod
    def check_javascript(code: str, function_name: str = None, test_cases: List[Dict] = None) -> Dict[str, Any]:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ JavaScript –∫–æ–¥–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Node.js"""
        try:
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–∑–æ–≤–æ–≥–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞
            if 'function' not in code and '=>' not in code:
                return {
                    'valid': False,
                    'error': '–ö–æ–¥ –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é',
                    'message': '‚ùå –ö–æ–¥ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –æ–±—ä—è–≤–ª–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏'
                }
            
            if not function_name or not test_cases:
                return {
                    'valid': True,
                    'language': 'javascript',
                    'message': '‚úÖ –°–∏–Ω—Ç–∞–∫—Å–∏—Å –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω (–±–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞)'
                }
            
            # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª —Å –∫–æ–¥–æ–º –∏ —Ç–µ—Å—Ç–∞–º–∏
            with tempfile.NamedTemporaryFile(mode='w', suffix='.js', delete=False, encoding='utf-8') as f:
                # –§–æ—Ä–º–∏—Ä—É–µ–º –∫–æ–¥ —Å —Ç–µ—Å—Ç–∞–º–∏
                test_code = code + '\n\n'
                test_code += '// –¢–µ—Å—Ç—ã\n'
                test_code += 'const tests = ' + json.dumps(test_cases) + ';\n\n'
                test_code += 'let passed = 0;\n'
                test_code += 'const results = [];\n\n'
                test_code += 'for (let i = 0; i < tests.length; i++) {\n'
                test_code += '    try {\n'
                test_code += '        const test = tests[i];\n'
                test_code += f'        const result = {function_name}(...test.input);\n'
                test_code += '        const expected = test.expected;\n'
                test_code += '        const success = JSON.stringify(result) === JSON.stringify(expected);\n'
                test_code += '        if (success) passed++;\n'
                test_code += '        results.push({\n'
                test_code += '            test_id: i+1,\n'
                test_code += '            input: test.input,\n'
                test_code += '            expected: expected,\n'
                test_code += '            actual: result,\n'
                test_code += '            passed: success,\n'
                test_code += '            error: null\n'
                test_code += '        });\n'
                test_code += '    } catch (e) {\n'
                test_code += '        results.push({\n'
                test_code += '            test_id: i+1,\n'
                test_code += '            input: tests[i].input,\n'
                test_code += '            expected: tests[i].expected,\n'
                test_code += '            actual: null,\n'
                test_code += '            passed: false,\n'
                test_code += '            error: e.toString()\n'
                test_code += '        });\n'
                test_code += '    }\n'
                test_code += '}\n\n'
                test_code += 'console.log(JSON.stringify({ passed: passed === tests.length, results: results, passed_count: passed, total_count: tests.length }));\n'
                
                f.write(test_code)
                temp_file = f.name
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º Node.js –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–¥–∞
            try:
                result = subprocess.run(['node', temp_file], 
                                       capture_output=True, 
                                       text=True, 
                                       timeout=5,
                                       encoding='utf-8')
                
                os.unlink(temp_file)  # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
                
                if result.returncode != 0:
                    return {
                        'passed': False,
                        'error': f'–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {result.stderr}',
                        'passed_count': 0,
                        'total_count': len(test_cases)
                    }
                
                # –ü–∞—Ä—Å–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                output = result.stdout.strip()
                # –ò—â–µ–º JSON –≤ –≤—ã–≤–æ–¥–µ
                import re
                json_match = re.search(r'\{.*\}', output, re.DOTALL)
                if json_match:
                    test_result = json.loads(json_match.group())
                    return test_result
                else:
                    return {
                        'passed': False,
                        'error': '–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç',
                        'output': output,
                        'passed_count': 0,
                        'total_count': len(test_cases)
                    }
                    
            except subprocess.TimeoutExpired:
                os.unlink(temp_file)
                return {
                    'passed': False,
                    'error': '–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (5 —Å–µ–∫)',
                    'passed_count': 0,
                    'total_count': len(test_cases)
                }
            except FileNotFoundError:
                return {
                    'passed': False,
                    'error': 'Node.js –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ',
                    'message': '‚ùå –î–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ JavaScript —Ç—Ä–µ–±—É–µ—Ç—Å—è Node.js',
                    'passed_count': 0,
                    'total_count': len(test_cases)
                }
                
        except Exception as e:
            return {
                'passed': False,
                'error': str(e),
                'passed_count': 0,
                'total_count': len(test_cases) if test_cases else 0
            }
    
    @staticmethod
    def check_java(code: str, function_name: str = None, test_cases: List[Dict] = None) -> Dict[str, Any]:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ Java –∫–æ–¥–∞"""
        try:
            # –ë–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∫–ª–∞—Å—Å–∞
            if 'class' not in code:
                return {
                    'valid': False,
                    'error': '–ö–æ–¥ –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∫–ª–∞—Å—Å',
                    'message': '‚ùå –ö–æ–¥ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –æ–±—ä—è–≤–ª–µ–Ω–∏—è –∫–ª–∞—Å—Å–∞'
                }
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–º—è –∫–ª–∞—Å—Å–∞ –∏–∑ –∫–æ–¥–∞
            import re
            class_match = re.search(r'(?:public\s+)?class\s+(\w+)', code)
            if not class_match:
                return {
                    'valid': False,
                    'error': '–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏–º—è –∫–ª–∞—Å—Å–∞',
                    'message': '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏–º—è –∫–ª–∞—Å—Å–∞'
                }
            
            class_name = class_match.group(1)
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∫–ª–∞—Å—Å public
            is_public = 'public class' in code
            
            # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –∏–º–µ–Ω–µ–º
            if is_public:
                # –î–ª—è public –∫–ª–∞—Å—Å–∞ –∏–º—è —Ñ–∞–π–ª–∞ –¥–æ–ª–∂–Ω–æ —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å –∏–º–µ–Ω–µ–º –∫–ª–∞—Å—Å–∞
                temp_dir = tempfile.gettempdir()
                temp_file = os.path.join(temp_dir, f"{class_name}.java")
                
                # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π —Ñ–∞–π–ª, –µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                if os.path.exists(temp_file):
                    os.unlink(temp_file)
                
                with open(temp_file, 'w', encoding='utf-8') as f:
                    f.write(code)
            else:
                # –î–ª—è non-public –∫–ª–∞—Å—Å–∞ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª—é–±–æ–µ –∏–º—è
                with tempfile.NamedTemporaryFile(mode='w', suffix='.java', delete=False, encoding='utf-8') as f:
                    f.write(code)
                    temp_file = f.name
            
            # –ï—Å–ª–∏ –Ω–µ—Ç —Ç–µ—Å—Ç–æ–≤, –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–º–ø–∏–ª—è—Ü–∏—é
            if not function_name or not test_cases:
                try:
                    compile_result = subprocess.run(['javac', temp_file], 
                                                   capture_output=True, 
                                                   text=True, 
                                                   timeout=10,
                                                   encoding='utf-8')
                    
                    success = compile_result.returncode == 0
                    os.unlink(temp_file)
                    
                    if success:
                        return {
                            'valid': True,
                            'language': 'java',
                            'message': '‚úÖ –ö–æ–º–ø–∏–ª—è—Ü–∏—è —É—Å–ø–µ—à–Ω–∞'
                        }
                    else:
                        return {
                            'valid': False,
                            'error': compile_result.stderr,
                            'message': '‚ùå –û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏'
                        }
                        
                except FileNotFoundError:
                    return {
                        'valid': False,
                        'error': 'Java JDK –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω',
                        'message': '‚ùå –î–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ Java —Ç—Ä–µ–±—É–µ—Ç—Å—è JDK'
                    }
            
            # –ö–æ–º–ø–∏–ª–∏—Ä—É–µ–º Java –∫–æ–¥
            try:
                compile_result = subprocess.run(['javac', temp_file], 
                                               capture_output=True, 
                                               text=True, 
                                               timeout=10,
                                               encoding='utf-8')
                
                if compile_result.returncode != 0:
                    os.unlink(temp_file)
                    return {
                        'passed': False,
                        'error': f'–û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏: {compile_result.stderr}',
                        'passed_count': 0,
                        'total_count': len(test_cases)
                    }
                
                # –ó–∞–ø—É—Å–∫–∞–µ–º Java –ø—Ä–æ–≥—Ä–∞–º–º—É
                class_path = os.path.dirname(temp_file)
                
                run_result = subprocess.run(['java', '-cp', class_path, class_name],
                                           capture_output=True,
                                           text=True,
                                           timeout=5,
                                           encoding='utf-8')
                
                # –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª—ã
                os.unlink(temp_file)
                class_file = os.path.join(class_path, class_name + '.class')
                if os.path.exists(class_file):
                    os.unlink(class_file)
                
                if run_result.returncode != 0:
                    return {
                        'passed': False,
                        'error': f'–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {run_result.stderr}',
                        'passed_count': 0,
                        'total_count': len(test_cases)
                    }
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—ã–≤–æ–¥ –ø—Ä–æ–≥—Ä–∞–º–º—ã
                output = run_result.stdout.strip()
                
                # –î–ª—è –∑–∞–¥–∞—á —Å —Ç–µ—Å—Ç–∞–º–∏
                if test_cases and len(test_cases) > 0:
                    test_results = []
                    passed_count = 0
                    
                    for i, test in enumerate(test_cases, 1):
                        expected = str(test['expected']).strip()
                        if expected in output:
                            passed_count += 1
                            test_results.append({
                                'test_id': i,
                                'input': test['input'],
                                'expected': expected,
                                'actual': output,
                                'passed': True,
                                'error': None
                            })
                        else:
                            test_results.append({
                                'test_id': i,
                                'input': test['input'],
                                'expected': expected,
                                'actual': output,
                                'passed': False,
                                'error': '–í—ã–≤–æ–¥ –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –æ–∂–∏–¥–∞–µ–º–æ–º—É'
                            })
                    
                    return {
                        'passed': passed_count == len(test_cases),
                        'test_results': test_results,
                        'passed_count': passed_count,
                        'total_count': len(test_cases),
                        'output': output
                    }
                
                return {
                    'passed': True,
                    'message': '‚úÖ –ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ',
                    'output': output
                }
                    
            except subprocess.TimeoutExpired:
                os.unlink(temp_file)
                return {
                    'passed': False,
                    'error': '–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (5 —Å–µ–∫)',
                    'passed_count': 0,
                    'total_count': len(test_cases)
                }
            except FileNotFoundError:
                return {
                    'passed': False,
                    'error': 'Java JDK –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ',
                    'message': '‚ùå –î–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ Java —Ç—Ä–µ–±—É–µ—Ç—Å—è JDK',
                    'passed_count': 0,
                    'total_count': len(test_cases)
                }
            except Exception as e:
                if os.path.exists(temp_file):
                    os.unlink(temp_file)
                return {
                    'passed': False,
                    'error': str(e),
                    'passed_count': 0,
                    'total_count': len(test_cases)
                }
                
        except Exception as e:
            return {
                'passed': False,
                'error': str(e),
                'passed_count': 0,
                'total_count': len(test_cases) if test_cases else 0
            }
    
    @staticmethod
    def check_code(code: str, language: str, function_name: str = None, test_cases: List[Dict] = None) -> Dict[str, Any]:
        """–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞ –Ω–∞ –ª—é–±–æ–º —è–∑—ã–∫–µ"""
        if language == 'python':
            return CodeChecker.check_python(code, function_name, test_cases)
        elif language == 'javascript':
            return CodeChecker.check_javascript(code, function_name, test_cases)
        elif language == 'java':
            return CodeChecker.check_java(code, function_name, test_cases)
        else:
            return {
                'valid': False,
                'error': f'–Ø–∑—ã–∫ {language} –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è',
                'message': f'‚ùå –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è {language} –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞'
            }

# ========== –§–£–ù–ö–¶–ò–ò –û–ü–†–ï–î–ï–õ–ï–ù–ò–Ø –Ø–ó–´–ö–ê ==========
def detect_language(code: str) -> str:
    """
    –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —è–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ –∫–æ–¥—É
    """
    code = code.strip()
    
    # –ü—Ä–∏–∑–Ω–∞–∫–∏ Java
    java_patterns = [
        r'public\s+class\s+\w+',
        r'public\s+static\s+void\s+main\s*\(',
        r'System\.out\.println',
        r'import\s+java\.',
        r'@Override',
        r'extends\s+\w+',
        r'implements\s+\w+',
        r'private\s+\w+\s+\w+\s*[=;]',
        r'protected\s+\w+\s+\w+\s*[=;]'
    ]
    
    # –ü—Ä–∏–∑–Ω–∞–∫–∏ JavaScript
    js_patterns = [
        r'function\s+\w+\s*\(',
        r'const\s+\w+\s*=',
        r'let\s+\w+\s*=',
        r'var\s+\w+\s*=',
        r'console\.log\s*\(',
        r'document\.',
        r'window\.',
        r'=>\s*{',
        r'export\s+(default\s+)?\w+',
        r'import\s+.*\s+from\s+[\'"]',
        r'require\s*\([\'"]'
    ]
    
    # –ü—Ä–∏–∑–Ω–∞–∫–∏ Python
    python_patterns = [
        r'def\s+\w+\s*\(',
        r'import\s+\w+',
        r'from\s+\w+\s+import',
        r'if\s+__name__\s*==\s*[\'"]__main__[\'"]',
        r'print\s*\(',
        r'class\s+\w+\s*:',
        r'elif\s+.+:',
        r'else\s*:',
        r'try\s*:',
        r'except\s+\w+\s*:',
        r'with\s+open\s*\(',
        r'lambda\s+\w+\s*:',
        r'@\w+'
    ]
    
    # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
    java_score = sum(1 for pattern in java_patterns if re.search(pattern, code, re.MULTILINE))
    js_score = sum(1 for pattern in js_patterns if re.search(pattern, code, re.MULTILINE))
    python_score = sum(1 for pattern in python_patterns if re.search(pattern, code, re.MULTILINE))
    
    # –û—Å–æ–±—ã–µ —Å–ª—É—á–∞–∏
    if 'public static void main' in code or 'System.out.println' in code:
        return 'java'
    if 'console.log' in code or ('function' in code and ('var' in code or 'let' in code or 'const' in code)):
        return 'javascript'
    if 'def ' in code and ':' in code or 'print(' in code:
        return 'python'
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —è–∑—ã–∫ —Å –Ω–∞–∏–±–æ–ª—å—à–∏–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
    scores = {'java': java_score, 'javascript': js_score, 'python': python_score}
    detected = max(scores, key=scores.get)
    
    # –ï—Å–ª–∏ —Å–æ–≤—Å–µ–º –Ω–µ—Ç —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º 'unknown'
    if scores[detected] == 0:
        return 'unknown'
    
    return detected

def format_result_message(result: dict, language: str, task: dict) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏"""
    
    if 'error' in result and result['error']:
        if 'Node.js' in result['error'] or 'JDK' in result['error']:
            return f"‚ùå *–û—à–∏–±–∫–∞:* {result['error']}"
        return f"‚ùå *–û—à–∏–±–∫–∞ –≤ –∫–æ–¥–µ:*\n```\n{result['error']}\n```"
    
    if result.get('passed', False):
        response = f"‚úÖ *–í–°–ï –¢–ï–°–¢–´ –ü–†–û–ô–î–ï–ù–´!*\n\n"
        response += f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –¢—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–µ—à–∏–ª –∑–∞–¥–∞—á—É –Ω–∞ *{language.capitalize()}*!\n\n"
    elif result.get('valid', False):
        response = f"‚úÖ *–°–ò–ù–¢–ê–ö–°–ò–° –í–ï–†–ù–´–ô*\n\n"
        response += f"–ö–æ–¥ –Ω–∞ *{language.capitalize()}* –Ω–∞–ø–∏—Å–∞–Ω –±–µ–∑ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–æ–∫.\n\n"
    else:
        response = f"‚ùå *–¢–ï–°–¢–´ –ù–ï –ü–†–û–ô–î–ï–ù–´*\n\n"
        response += f"–ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤: {result.get('passed_count', 0)}/{result.get('total_count', len(task['test_cases']))}\n\n"
    
    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–æ–≤
    if 'test_results' in result and result['test_results']:
        response += "*–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–æ–≤:*\n"
        for test in result['test_results']:
            if test.get('passed'):
                response += f"‚úÖ –¢–µ—Å—Ç {test['test_id']}: {test['input']} ‚Üí {test['actual']}\n"
            else:
                response += f"‚ùå –¢–µ—Å—Ç {test['test_id']}: {test['input']} ‚Üí "
                if test.get('actual') is None:
                    response += f"–û—à–∏–±–∫–∞: {test.get('error', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞')}\n"
                else:
                    response += f"–ø–æ–ª—É—á–µ–Ω–æ {test['actual']}, –æ–∂–∏–¥–∞–ª–æ—Å—å {test['expected']}\n"
    
    return response

# ========== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ==========
BOT_TOKEN = "8533950306:AAFDADV8ksvHmw1e8ELqthKWs0Osoua91h8"

# ========== –ë–ê–ó–ê –í–û–ü–†–û–°–û–í ==========
QUESTIONS = {
    'python': [
        {
            'question': '–ö–∞–∫ –≤—ã–≤–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç –≤ Python?', 
            'options': ['print("text")', 'console.log("text")', 'echo "text"', 'System.out.println("text")'], 
            'correct': 0
        },
        {
            'question': '–ö–∞–∫ —Å–æ–∑–¥–∞—Ç—å —Å–ø–∏—Å–æ–∫ –≤ Python?', 
            'options': ['list = []', 'array = []', 'arr = []', 'list()'], 
            'correct': 0
        },
        {
            'question': '–ö–∞–∫–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–ª–∏–Ω—É —Å–ø–∏—Å–∫–∞?', 
            'options': ['size()', 'length()', 'len()', 'count()'], 
            'correct': 2
        },
        {
            'question': '–ö–∞–∫ –æ–±—ä—è–≤–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –≤ Python?', 
            'options': ['function myFunc():', 'def myFunc():', 'func myFunc():', 'define myFunc():'], 
            'correct': 1
        }
    ],
    
    'javascript': [
        {
            'question': '–ö–∞–∫ –≤—ã–≤–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç –≤ JavaScript?', 
            'options': ['print("text")', 'console.log("text")', 'echo "text"', 'System.out.println("text")'], 
            'correct': 1
        },
        {
            'question': '–ö–∞–∫ –æ–±—ä—è–≤–∏—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –≤ JS?', 
            'options': ['var x;', 'let x;', 'const x;', '–í—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã'], 
            'correct': 3
        },
        {
            'question': '–ö–∞–∫ —Å–æ–∑–¥–∞—Ç—å –º–∞—Å—Å–∏–≤ –≤ JS?', 
            'options': ['[]', '{}', '()', '<>'], 
            'correct': 0
        },
        {
            'question': '–ö–∞–∫ –æ–±—ä—è–≤–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –≤ JavaScript?',
            'options': ['function myFunc() {}', 'def myFunc() {}', 'func myFunc()', 'create function myFunc()'],
            'correct': 0
        }
    ],
    
    'java': [
        {
            'question': '–ö–∞–∫ –≤—ã–≤–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç –≤ Java?', 
            'options': ['print("text")', 'console.log("text")', 'System.out.println("text")', 'echo "text"'], 
            'correct': 2
        },
        {
            'question': '–ß—Ç–æ —Ç–∞–∫–æ–µ JVM?', 
            'options': ['Java Virtual Machine', 'Java Visual Model', 'Java Variable Memory', 'Java Version Manager'], 
            'correct': 0
        },
        {
            'question': '–ö–∞–∫–æ–µ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ –¥–ª—è –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è?', 
            'options': ['extends', 'implements', 'inherits', 'super'], 
            'correct': 0
        },
        {
            'question': '–ö–∞–∫ –æ–±—ä—è–≤–∏—Ç—å –º–µ—Ç–æ–¥ –≤ Java?',
            'options': ['public void method() {}', 'function method() {}', 'def method() {}', 'method() {}'],
            'correct': 0
        }
    ]
}

# ========= –ó–ê–î–ê–ù–ò–Ø –ü–û –ö–ê–¢–ï–ì–û–†–ò–Ø–ú =========
TASKS = {
    'python': {
        'syntax': [
            {
                'id': 'py_syntax_print',
                'title': 'üìù –°–∏–Ω—Ç–∞–∫—Å–∏—Å: –í—ã–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞',
                'difficulty': 'easy',
                'category': 'syntax',
                'description': '–ù–∞–ø–∏—à–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É, –∫–æ—Ç–æ—Ä–∞—è –≤—ã–≤–æ–¥–∏—Ç –Ω–∞ —ç–∫—Ä–∞–Ω —Ñ—Ä–∞–∑—É "Hello, World!"',
                'function_name': None,
                'template': '# –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥ –∑–¥–µ—Å—å\nprint()',
                'test_cases': [
                    {'input': [], 'expected': 'Hello, World!\n', 'type': 'output'}
                ],
                'hint': '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é print()',
                'solution': 'print("Hello, World!")'
            },
            {
                'id': 'py_syntax_variables',
                'title': 'üìù –°–∏–Ω—Ç–∞–∫—Å–∏—Å: –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ',
                'difficulty': 'easy',
                'category': 'syntax',
                'description': '–°–æ–∑–¥–∞–π—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é name —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º "Python" –∏ –≤—ã–≤–µ–¥–∏—Ç–µ –µ—ë',
                'function_name': None,
                'template': '# –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥ –∑–¥–µ—Å—å',
                'test_cases': [
                    {'input': [], 'expected': 'Python\n', 'type': 'output'}
                ],
                'hint': 'name = "Python"; print(name)',
                'solution': 'name = "Python"\nprint(name)'
            }
        ],
        'logic': [
            {
                'id': 'py_logic_even',
                'title': 'üß† –õ–æ–≥–∏–∫–∞: –ß—ë—Ç–Ω—ã–µ —á–∏—Å–ª–∞',
                'difficulty': 'medium',
                'category': 'logic',
                'description': '–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é is_even(n), –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ —á–∏—Å–ª–æ —á—ë—Ç–Ω–æ–µ',
                'function_name': 'is_even',
                'template': 'def is_even(n):\n    # –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥ –∑–¥–µ—Å—å\n    pass',
                'test_cases': [
                    {'input': [2], 'expected': True},
                    {'input': [3], 'expected': False},
                    {'input': [0], 'expected': True},
                    {'input': [100], 'expected': True}
                ],
                'hint': '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä %',
                'solution': 'def is_even(n):\n    return n % 2 == 0'
            },
            {
                'id': 'py_logic_max',
                'title': 'üß† –õ–æ–≥–∏–∫–∞: –ú–∞–∫—Å–∏–º—É–º –∏–∑ —Ç—Ä—ë—Ö',
                'difficulty': 'medium',
                'category': 'logic',
                'description': '–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é max_of_three(a, b, c), –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–∞–∏–±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ',
                'function_name': 'max_of_three',
                'template': 'def max_of_three(a, b, c):\n    # –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥ –∑–¥–µ—Å—å\n    pass',
                'test_cases': [
                    {'input': [1, 2, 3], 'expected': 3},
                    {'input': [10, 5, 7], 'expected': 10},
                    {'input': [-1, -5, 0], 'expected': 0}
                ],
                'hint': '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ max() –∏–ª–∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è',
                'solution': 'def max_of_three(a, b, c):\n    return max(a, b, c)'
            }
        ],
        'project': [
            {
                'id': 'py_project_calculator',
                'title': 'üöÄ –ü—Ä–æ–µ–∫—Ç: –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä',
                'difficulty': 'hard',
                'category': 'project',
                'description': '–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é calculator(a, b, op), –∫–æ—Ç–æ—Ä–∞—è –≤—ã–ø–æ–ª–Ω—è–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏—é op (+, -, *, /) –Ω–∞–¥ —á–∏—Å–ª–∞–º–∏ a –∏ b',
                'function_name': 'calculator',
                'template': 'def calculator(a, b, op):\n    # –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥ –∑–¥–µ—Å—å\n    pass',
                'test_cases': [
                    {'input': [5, 3, '+'], 'expected': 8},
                    {'input': [10, 4, '-'], 'expected': 6},
                    {'input': [6, 7, '*'], 'expected': 42},
                    {'input': [15, 3, '/'], 'expected': 5.0}
                ],
                'hint': '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ if-elif –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞',
                'solution': 'def calculator(a, b, op):\n    if op == "+":\n        return a + b\n    elif op == "-":\n        return a - b\n    elif op == "*":\n        return a * b\n    elif op == "/":\n        return a / b'
            },
            {
                'id': 'py_project_fibonacci',
                'title': 'üöÄ –ü—Ä–æ–µ–∫—Ç: –ß–∏—Å–ª–∞ –§–∏–±–æ–Ω–∞—á—á–∏',
                'difficulty': 'hard',
                'category': 'project',
                'description': '–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é fibonacci(n), –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç n-–µ —á–∏—Å–ª–æ –§–∏–±–æ–Ω–∞—á—á–∏',
                'function_name': 'fibonacci',
                'template': 'def fibonacci(n):\n    # –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥ –∑–¥–µ—Å—å\n    pass',
                'test_cases': [
                    {'input': [0], 'expected': 0},
                    {'input': [1], 'expected': 1},
                    {'input': [5], 'expected': 5},
                    {'input': [10], 'expected': 55}
                ],
                'hint': '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ü–∏–∫–ª –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è',
                'solution': 'def fibonacci(n):\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(n-1):\n        a, b = b, a + b\n    return b'
            }
        ]
    },
    
    'javascript': {
        'syntax': [
            {
                'id': 'js_syntax_hello',
                'title': 'üìù –°–∏–Ω—Ç–∞–∫—Å–∏—Å: –í—ã–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞',
                'difficulty': 'easy',
                'category': 'syntax',
                'description': '–ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–≤–æ–¥–∏—Ç –≤ –∫–æ–Ω—Å–æ–ª—å "Hello, World!"',
                'function_name': None,
                'template': '// –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥ –∑–¥–µ—Å—å\nconsole.log()',
                'test_cases': [
                    {'input': [], 'expected': 'Hello, World!\n', 'type': 'output'}
                ],
                'hint': '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ console.log()',
                'solution': 'console.log("Hello, World!");'
            }
        ],
        'logic': [
            {
                'id': 'js_logic_even',
                'title': 'üß† –õ–æ–≥–∏–∫–∞: –ß—ë—Ç–Ω—ã–µ —á–∏—Å–ª–∞',
                'difficulty': 'medium',
                'category': 'logic',
                'description': '–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é isEven(n), –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç true, –µ—Å–ª–∏ —á–∏—Å–ª–æ —á—ë—Ç–Ω–æ–µ',
                'function_name': 'isEven',
                'template': 'function isEven(n) {\n    // –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥ –∑–¥–µ—Å—å\n}',
                'test_cases': [
                    {'input': [2], 'expected': True},
                    {'input': [3], 'expected': False},
                    {'input': [0], 'expected': True}
                ],
                'hint': '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä %',
                'solution': 'function isEven(n) {\n    return n % 2 === 0;\n}'
            }
        ],
        'project': [
            {
                'id': 'js_project_factorial',
                'title': 'üöÄ –ü—Ä–æ–µ–∫—Ç: –§–∞–∫—Ç–æ—Ä–∏–∞–ª',
                'difficulty': 'hard',
                'category': 'project',
                'description': '–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é factorial(n), –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ–∞–∫—Ç–æ—Ä–∏–∞–ª —á–∏—Å–ª–∞',
                'function_name': 'factorial',
                'template': 'function factorial(n) {\n    // –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥ –∑–¥–µ—Å—å\n}',
                'test_cases': [
                    {'input': [0], 'expected': 1},
                    {'input': [1], 'expected': 1},
                    {'input': [5], 'expected': 120}
                ],
                'hint': '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä–µ–∫—É—Ä—Å–∏—é –∏–ª–∏ —Ü–∏–∫–ª',
                'solution': 'function factorial(n) {\n    if (n <= 1) return 1;\n    return n * factorial(n - 1);\n}'
            }
        ]
    },
    
    'java': {
        'syntax': [
            {
                'id': 'java_syntax_main',
                'title': 'üìù –°–∏–Ω—Ç–∞–∫—Å–∏—Å: Hello World',
                'difficulty': 'easy',
                'category': 'syntax',
                'description': '–ù–∞–ø–∏—à–∏—Ç–µ –º–µ—Ç–æ–¥ main, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–≤–æ–¥–∏—Ç "Hello, World!"',
                'function_name': 'main',
                'template': 'public class Main {\n    public static void main(String[] args) {\n        // –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥ –∑–¥–µ—Å—å\n    }\n}',
                'test_cases': [
                    {'input': [], 'expected': 'Hello, World!\n', 'type': 'output'}
                ],
                'hint': '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ System.out.println()',
                'solution': 'public class Main {\n    public static void main(String[] args) {\n        System.out.println("Hello, World!");\n    }\n}'
            }
        ],
        'logic': [
            {
                'id': 'java_logic_max',
                'title': 'üß† –õ–æ–≥–∏–∫–∞: –ú–∞–∫—Å–∏–º—É–º',
                'difficulty': 'medium',
                'category': 'logic',
                'description': '–ù–∞–ø–∏—à–∏—Ç–µ –º–µ—Ç–æ–¥ max(int a, int b), –∫–æ—Ç–æ—Ä—ã–π –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ',
                'function_name': 'max',
                'template': 'public static int max(int a, int b) {\n    // –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥ –∑–¥–µ—Å—å\n}',
                'test_cases': [
                    {'input': [5, 3], 'expected': 5},
                    {'input': [2, 7], 'expected': 7},
                    {'input': [4, 4], 'expected': 4}
                ],
                'hint': '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ if –∏–ª–∏ Math.max()',
                'solution': 'public static int max(int a, int b) {\n    return Math.max(a, b);\n}'
            }
        ],
        'project': [
            {
                'id': 'java_project_sum',
                'title': 'üöÄ –ü—Ä–æ–µ–∫—Ç: –°—É–º–º–∞ –º–∞—Å—Å–∏–≤–∞',
                'difficulty': 'hard',
                'category': 'project',
                'description': '–ù–∞–ø–∏—à–∏—Ç–µ –º–µ—Ç–æ–¥ sumArray(int[] arr), –∫–æ—Ç–æ—Ä—ã–π –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—É–º–º—É –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤',
                'function_name': 'sumArray',
                'template': 'public static int sumArray(int[] arr) {\n    // –ù–∞–ø–∏—à–∏—Ç–µ –∫–æ–¥ –∑–¥–µ—Å—å\n}',
                'test_cases': [
                    {'input': [[1, 2, 3, 4, 5]], 'expected': 15},
                    {'input': [[10, 20, 30]], 'expected': 60},
                    {'input': [[-1, -2, -3]], 'expected': -6}
                ],
                'hint': '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ü–∏–∫–ª for',
                'solution': 'public static int sumArray(int[] arr) {\n    int sum = 0;\n    for (int i = 0; i < arr.length; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}'
            }
        ]
    }
}

# ========= –°–û–°–¢–û–Ø–ù–ò–Ø –î–õ–Ø FSM =========
class TrainingStates(StatesGroup):
    """–°–æ—Å—Ç–æ—è–Ω–∏—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏"""
    choosing_language = State()
    choosing_mode = State()
    choosing_category = State()
    answering = State()
    solving_task = State()
    waiting_for_code = State()
    waiting_for_task_choice = State()

# ========= –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø =========
logging.basicConfig(level=logging.INFO)
storage = MemoryStorage()
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher(storage=storage)

# ========== –†–ê–ë–û–¢–ê –° –ë–ê–ó–û–ô –î–ê–ù–ù–´–• ==========
conn = sqlite3.connect('trainer.db', check_same_thread=False)
cursor = conn.cursor()

cursor.executescript('''
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        username TEXT,
        first_name TEXT,
        registered_at TEXT
    );
    
    CREATE TABLE IF NOT EXISTS stats (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        language TEXT,
        correct_answers INTEGER,
        total_questions INTEGER,
        date TEXT
    );
    
    CREATE TABLE IF NOT EXISTS user_sessions (
        user_id INTEGER PRIMARY KEY,
        language TEXT,
        question_index INTEGER,
        correct_count INTEGER,
        total_count INTEGER
    );
    
    CREATE TABLE IF NOT EXISTS task_attempts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        task_id TEXT,
        code TEXT,
        passed_tests INTEGER,
        total_tests INTEGER,
        date TEXT
    );
''')
conn.commit()

# ========== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–ë–û–¢–´ –° –ë–ê–ó–û–ô –î–ê–ù–ù–´–• ==========
def add_user(user_id, username, first_name):
    cursor.execute('INSERT OR IGNORE INTO users VALUES (?, ?, ?, ?)',
                   (user_id, username, first_name, datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
    conn.commit()

def start_session(user_id, language):
    cursor.execute('INSERT OR REPLACE INTO user_sessions VALUES (?, ?, 0, 0, ?)',
                   (user_id, language, len(QUESTIONS[language])))
    conn.commit()

def update_session(user_id, question_index, correct_count):
    cursor.execute('UPDATE user_sessions SET question_index = ?, correct_count = ? WHERE user_id = ?',
                   (question_index, correct_count, user_id))
    conn.commit()

def get_session(user_id):
    cursor.execute('SELECT * FROM user_sessions WHERE user_id = ?', (user_id,))
    return cursor.fetchone()

def end_session(user_id):
    cursor.execute('DELETE FROM user_sessions WHERE user_id = ?', (user_id,))
    conn.commit()

def save_stats(user_id, language, correct, total):
    cursor.execute('INSERT INTO stats (user_id, language, correct_answers, total_questions, date) VALUES (?, ?, ?, ?, ?)',
                   (user_id, language, correct, total, datetime.now().strftime("%Y-%m-%d")))
    conn.commit()

def get_user_stats(user_id):
    cursor.execute('''
        SELECT language, correct_answers, total_questions, date 
        FROM stats 
        WHERE user_id = ? 
        ORDER BY date DESC
    ''', (user_id,))
    return cursor.fetchall()

def save_task_attempt(user_id, task_id, code, passed_tests, total_tests):
    cursor.execute('''
        INSERT INTO task_attempts (user_id, task_id, code, passed_tests, total_tests, date)
        VALUES (?, ?, ?, ?, ?, ?)
    ''', (user_id, task_id, code[:500], passed_tests, total_tests, datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
    conn.commit()

# ========== –°–û–ó–î–ê–ù–ò–ï –ö–õ–ê–í–ò–ê–¢–£–† ==========
def get_main_keyboard():
    keyboard = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üìö –¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞")],
            [
                KeyboardButton(text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
                KeyboardButton(text="‚ÑπÔ∏è –û –±–æ—Ç–µ")
            ]
        ],
        resize_keyboard=True,
        input_field_placeholder="–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ..."
    )
    return keyboard

def get_languages_keyboard():
    builder = InlineKeyboardBuilder()
    builder.add(InlineKeyboardButton(text="Python", callback_data="lang_python"))
    builder.add(InlineKeyboardButton(text="JavaScript", callback_data="lang_javascript"))
    builder.add(InlineKeyboardButton(text="Java", callback_data="lang_java"))
    builder.adjust(2, 1)
    return builder.as_markup()

def get_modes_keyboard():
    builder = InlineKeyboardBuilder()
    builder.add(InlineKeyboardButton(text="‚ùì –û—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã", callback_data="mode_questions"))
    builder.add(InlineKeyboardButton(text="üìù –†–µ—à–∞—Ç—å –∑–∞–¥–∞—á–∏", callback_data="mode_tasks"))
    builder.adjust(1)
    return builder.as_markup()

def get_categories_keyboard(language):
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –≤—ã–±–æ—Ä–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∑–∞–¥–∞—á"""
    builder = InlineKeyboardBuilder()
    
    if language in TASKS:
        if TASKS[language].get('syntax'):
            builder.add(InlineKeyboardButton(
                text="üìù –°–∏–Ω—Ç–∞–∫—Å–∏—Å",
                callback_data=f"cat_syntax"
            ))
        if TASKS[language].get('logic'):
            builder.add(InlineKeyboardButton(
                text="üß† –õ–æ–≥–∏–∫–∞",
                callback_data=f"cat_logic"
            ))
        if TASKS[language].get('project'):
            builder.add(InlineKeyboardButton(
                text="üöÄ –ü—Ä–æ–µ–∫—Ç—ã",
                callback_data=f"cat_project"
            ))
    
    builder.add(InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_modes"))
    builder.adjust(1)
    return builder.as_markup()

def get_tasks_keyboard(language, category):
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –≤—ã–±–æ—Ä–∞ –∑–∞–¥–∞—á–∏ –∏–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏"""
    builder = InlineKeyboardBuilder()
    
    if language in TASKS and category in TASKS[language]:
        for task in TASKS[language][category]:
            difficulty_emoji = "üü¢" if task['difficulty'] == 'easy' else "üü°" if task['difficulty'] == 'medium' else "üî¥"
            builder.add(InlineKeyboardButton(
                text=f"{difficulty_emoji} {task['title']}",
                callback_data=f"task_{task['id']}"
            ))
    
    builder.add(InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º", callback_data="back_to_categories"))
    builder.adjust(1)
    return builder.as_markup()

# ========== –§–£–ù–ö–¶–ò–Ø –û–¢–ü–†–ê–í–ö–ò –í–û–ü–†–û–°–ê ==========
async def send_question(user_id: int, language: str, q_index: int, state: FSMContext):
    questions = QUESTIONS[language]
    
    if q_index >= len(questions):
        session = get_session(user_id)
        if session:
            _, _, _, correct, total = session
            save_stats(user_id, language, correct, total)
            end_session(user_id)
            await state.clear()
            
            percent = (correct / total) * 100
            await bot.send_message(
                user_id,
                f"üéâ *–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!*\n\n"
                f"–Ø–∑—ã–∫: *{language.capitalize()}*\n"
                f"–†–µ–∑—É–ª—å—Ç–∞—Ç: *{correct}/{total}* ({percent:.1f}%)\n\n"
                f"–•–æ—Ç–∏—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â–µ?",
                parse_mode="Markdown",
                reply_markup=get_main_keyboard()
            )
        return
    
    q = questions[q_index]
    builder = InlineKeyboardBuilder()
    
    for i, option in enumerate(q['options']):
        builder.add(InlineKeyboardButton(
            text=option,
            callback_data=f"ans_{language}_{q_index}_{i}"
        ))
    
    builder.adjust(1)
    
    await bot.send_message(
        user_id,
        f"‚ùì *–í–æ–ø—Ä–æ—Å {q_index + 1}/{len(questions)}*\n\n"
        f"{q['question']}",
        parse_mode="Markdown",
        reply_markup=builder.as_markup()
    )

# ========== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ö–û–ú–ê–ù–î ==========
@dp.message(Command("start"))
async def cmd_start(message: Message, state: FSMContext):
    add_user(message.from_user.id, message.from_user.username, message.from_user.first_name)
    await state.clear()
    await message.answer(
        f"üëã *–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}!*\n\n"
        f"–Ø –±–æ—Ç-—Ç—Ä–µ–Ω–∞–∂–µ—Ä –ø–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—é.\n\n"
        f"*–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:*",
        parse_mode="Markdown",
        reply_markup=get_main_keyboard()
    )

@dp.message(F.text == "üìö –¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞")
async def start_training(message: Message, state: FSMContext):
    await state.set_state(TrainingStates.choosing_language)
    await message.answer("–í—ã–±–µ—Ä–∏ —è–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è:", reply_markup=get_languages_keyboard())

@dp.message(F.text == "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
async def show_stats(message: Message, state: FSMContext):
    stats = get_user_stats(message.from_user.id)
    
    if not stats:
        await message.answer(
            "üìä *–£ —Ç–µ–±—è –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫.*",
            parse_mode="Markdown",
            reply_markup=get_main_keyboard()
        )
        return
    
    text = "üìä *–¢–≤–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:*\n\n"
    for lang, correct, total, date in stats:
        percent = (correct / total * 100) if total > 0 else 0
        text += f"üîπ *{lang.capitalize()}*: {correct}/{total} ({percent:.1f}%)\n   üìÖ {date}\n\n"
    
    await message.answer(text, parse_mode="Markdown", reply_markup=get_main_keyboard())

@dp.message(F.text == "‚ÑπÔ∏è –û –±–æ—Ç–µ")
async def about_bot(message: Message, state: FSMContext):
    await message.answer(
        "ü§ñ *–¢—Ä–µ–Ω–∞–∂–µ—Ä –ø–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—é*\n\n"
        "*–í–µ—Ä—Å–∏—è:* 2.0\n"
        "*–Ø–∑—ã–∫–∏:* Python, JavaScript, Java\n\n"
        "*–†–µ–∂–∏–º—ã:*\n"
        "üìù –°–∏–Ω—Ç–∞–∫—Å–∏—Å - –ø—Ä–æ—Å—Ç—ã–µ –∑–∞–¥–∞—á–∏ –Ω–∞ –∑–Ω–∞–Ω–∏–µ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞\n"
        "üß† –õ–æ–≥–∏–∫–∞ - –∑–∞–¥–∞—á–∏ –Ω–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∏—á–µ—Å–∫–æ–µ –º—ã—à–ª–µ–Ω–∏–µ\n"
        "üöÄ –ü—Ä–æ–µ–∫—Ç—ã - –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–µ –∑–∞–¥–∞—á–∏\n"
        "‚ùì –í–æ–ø—Ä–æ—Å—ã - —Ç–µ–æ—Ä–∏—è\n\n"
        "*–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞:*\n"
        "‚úÖ Python - –ø–æ–ª–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞\n"
        "‚úÖ JavaScript - —Ç—Ä–µ–±—É–µ—Ç Node.js\n"
        "‚úÖ Java - —Ç—Ä–µ–±—É–µ—Ç JDK\n\n"
        "–£–¥–∞—á–∏ –≤ –æ–±—É—á–µ–Ω–∏–∏! üöÄ",
        parse_mode="Markdown",
        reply_markup=get_main_keyboard()
    )

# ========== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò CALLBACK ==========
@dp.callback_query(F.data.startswith("lang_"))
async def process_language(callback: CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—ã–±–æ—Ä —è–∑—ã–∫–∞"""
    language = callback.data.replace("lang_", "")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∑–∞–¥–∞—á–∏ –∏ –≤–æ–ø—Ä–æ—Å—ã –¥–ª—è —ç—Ç–æ–≥–æ —è–∑—ã–∫–∞
    if language in TASKS and language in QUESTIONS:
        await state.update_data(language=language)
        await state.set_state(TrainingStates.choosing_mode)
        
        await callback.message.edit_text(
            f"–í—ã–±—Ä–∞–Ω —è–∑—ã–∫: *{language.capitalize()}*\n\n–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏:",
            parse_mode="Markdown",
            reply_markup=get_modes_keyboard()
        )
    else:
        # –ï—Å–ª–∏ —è–∑—ã–∫–∞ –Ω–µ—Ç –≤ –±–∞–∑–µ
        await callback.answer(
            f"–Ø–∑—ã–∫ {language.capitalize()} —Å–∫–æ—Ä–æ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω!",
            show_alert=True
        )
    
    await callback.answer()

@dp.callback_query(F.data == "back_to_modes")
async def back_to_modes(callback: CallbackQuery, state: FSMContext):
    await state.set_state(TrainingStates.choosing_mode)
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏:", reply_markup=get_modes_keyboard())
    await callback.answer()

@dp.callback_query(F.data == "back_to_categories")
async def back_to_categories(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    language = data.get('language', 'python')
    await state.set_state(TrainingStates.choosing_category)
    await callback.message.edit_text(
        f"üìö *–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∑–∞–¥–∞—á –¥–ª—è {language.capitalize()}:*",
        parse_mode="Markdown",
        reply_markup=get_categories_keyboard(language)
    )
    await callback.answer()

@dp.callback_query(F.data.startswith("mode_"))
async def process_mode(callback: CallbackQuery, state: FSMContext):
    mode = callback.data.replace("mode_", "")
    data = await state.get_data()
    language = data.get('language', 'python')
    
    if mode == "questions":
        start_session(callback.from_user.id, language)
        await state.set_state(TrainingStates.answering)
        await send_question(callback.from_user.id, language, 0, state)
    elif mode == "tasks":
        await state.set_state(TrainingStates.choosing_category)
        await callback.message.edit_text(
            f"üìö *–í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∑–∞–¥–∞—á –¥–ª—è {language.capitalize()}:*",
            parse_mode="Markdown",
            reply_markup=get_categories_keyboard(language)
        )
    
    await callback.answer()

@dp.callback_query(F.data.startswith("cat_"))
async def process_category(callback: CallbackQuery, state: FSMContext):
    category = callback.data.replace("cat_", "")
    data = await state.get_data()
    language = data.get('language', 'python')
    
    await state.update_data(category=category)
    await state.set_state(TrainingStates.waiting_for_task_choice)
    
    category_names = {
        'syntax': 'üìù –°–∏–Ω—Ç–∞–∫—Å–∏—Å',
        'logic': 'üß† –õ–æ–≥–∏–∫–∞',
        'project': 'üöÄ –ü—Ä–æ–µ–∫—Ç—ã'
    }
    
    await callback.message.edit_text(
        f"{category_names.get(category, category)} *–¥–ª—è {language.capitalize()}:*\n\n–í—ã–±–µ—Ä–∏ –∑–∞–¥–∞—á—É:",
        parse_mode="Markdown",
        reply_markup=get_tasks_keyboard(language, category)
    )
    await callback.answer()

@dp.callback_query(F.data.startswith("task_"))
async def process_task_choice(callback: CallbackQuery, state: FSMContext):
    task_id = callback.data.replace("task_", "")
    await state.update_data(current_task_id=task_id)
    
    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π —è–∑—ã–∫ –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é
    data = await state.get_data()
    current_language = data.get('language', 'python')
    current_category = data.get('category', 'syntax')
    
    # –ò—â–µ–º –∑–∞–¥–∞—á—É –≤ –Ω—É–∂–Ω–æ–º —è–∑—ã–∫–µ –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    task = None
    if current_language in TASKS and current_category in TASKS[current_language]:
        for t in TASKS[current_language][current_category]:
            if t['id'] == task_id:
                task = t
                break
    
    if task:
        builder = InlineKeyboardBuilder()
        builder.add(InlineKeyboardButton(text="‚úèÔ∏è –ù–∞–ø–∏—Å–∞—Ç—å —Ä–µ—à–µ–Ω–∏–µ", callback_data=f"solve_{task_id}"))
        builder.add(InlineKeyboardButton(text="üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞", callback_data=f"hint_{task_id}"))
        builder.add(InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∑–∞–¥–∞—á–∞–º", callback_data="back_to_categories"))
        builder.adjust(1)
        
        difficulty_emoji = "üü¢" if task['difficulty'] == 'easy' else "üü°" if task['difficulty'] == 'medium' else "üî¥"
        
        await callback.message.edit_text(
            f"{difficulty_emoji} *{task['title']}*\n\n"
            f"üìù *–û–ø–∏—Å–∞–Ω–∏–µ:*\n{task['description']}\n\n"
            f"‚öôÔ∏è *–§—É–Ω–∫—Ü–∏—è:* `{task['function_name'] if task['function_name'] else '–ø—Ä–æ–≥—Ä–∞–º–º–∞'}`\n\n"
            f"üìä *–¢–µ—Å—Ç–æ–≤:* {len(task['test_cases'])}\n\n"
            f"–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
            parse_mode="Markdown",
            reply_markup=builder.as_markup()
        )
    else:
        await callback.answer("–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
    
    await callback.answer()

@dp.callback_query(F.data.startswith("solve_"))
async def solve_task(callback: CallbackQuery, state: FSMContext):
    task_id = callback.data.replace("solve_", "")
    
    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π —è–∑—ã–∫ –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é
    data = await state.get_data()
    current_language = data.get('language', 'python')
    current_category = data.get('category', 'syntax')
    
    # –ò—â–µ–º –∑–∞–¥–∞—á—É –≤ –Ω—É–∂–Ω–æ–º —è–∑—ã–∫–µ –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    task = None
    if current_language in TASKS and current_category in TASKS[current_language]:
        for t in TASKS[current_language][current_category]:
            if t['id'] == task_id:
                task = t
                break
    
    if task:
        await state.update_data(current_task_id=task_id)
        await state.set_state(TrainingStates.waiting_for_code)
        
        template_lang = "python" if current_language == "python" else "javascript" if current_language == "javascript" else "java"
        
        await callback.message.edit_text(
            f"‚úèÔ∏è *–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏: {task['title']}*\n\n"
            f"–ù–∞–ø–∏—à–∏ –∫–æ–¥ –∏ –æ—Ç–ø—Ä–∞–≤—å –µ–≥–æ –º–Ω–µ.\n\n"
            f"*–ü—Ä–∏–º–µ—Ä —à–∞–±–ª–æ–Ω–∞:*\n"
            f"```{template_lang}\n{task['template']}\n```\n\n"
            f"–û—Ç–ø—Ä–∞–≤—å –∫–æ–¥ –∏ —è –ø—Ä–æ–≤–µ—Ä—é –µ–≥–æ!",
            parse_mode="Markdown"
        )
    else:
        await callback.answer("–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
    
    await callback.answer()

@dp.callback_query(F.data.startswith("hint_"))
async def show_hint(callback: CallbackQuery, state: FSMContext):
    task_id = callback.data.replace("hint_", "")
    
    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π —è–∑—ã–∫ –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é
    data = await state.get_data()
    current_language = data.get('language', 'python')
    current_category = data.get('category', 'syntax')
    
    # –ò—â–µ–º –∑–∞–¥–∞—á—É –≤ –Ω—É–∂–Ω–æ–º —è–∑—ã–∫–µ –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    task = None
    if current_language in TASKS and current_category in TASKS[current_language]:
        for t in TASKS[current_language][current_category]:
            if t['id'] == task_id:
                task = t
                break
    
    if task and 'hint' in task:
        await callback.answer(task['hint'], show_alert=True)
    else:
        await callback.answer("–ü–æ–¥—Å–∫–∞–∑–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)

@dp.callback_query(F.data.startswith("ans_"))
async def process_answer(callback: CallbackQuery, state: FSMContext):
    _, language, q_idx, ans_idx = callback.data.split("_")
    q_idx = int(q_idx)
    ans_idx = int(ans_idx)
    user_id = callback.from_user.id
    
    session = get_session(user_id)
    
    if not session:
        await callback.answer("–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞. –ù–∞—á–Ω–∏ –∑–∞–Ω–æ–≤–æ!", show_alert=True)
        await state.clear()
        return
    
    _, _, _, correct_count, _ = session
    is_correct = (ans_idx == QUESTIONS[language][q_idx]['correct'])
    
    if is_correct:
        correct_count += 1
        await callback.answer("‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ!")
    else:
        correct_answer = QUESTIONS[language][q_idx]['options'][QUESTIONS[language][q_idx]['correct']]
        await callback.answer(f"‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ!\n–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: {correct_answer}", show_alert=True)
    
    update_session(user_id, q_idx + 1, correct_count)
    await send_question(user_id, language, q_idx + 1, state)

@dp.callback_query(F.data == "back_to_main")
async def back_to_main(callback: CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.delete()
    await callback.message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=get_main_keyboard())
    await callback.answer()

# ========== –û–ë–†–ê–ë–û–¢–ß–ò–ö –ü–û–õ–£–ß–ï–ù–ò–Ø –ö–û–î–ê ==========
@dp.message(TrainingStates.waiting_for_code)
async def process_task_code(message: Message, state: FSMContext):
    code = message.text
    data = await state.get_data()
    task_id = data.get('current_task_id')
    selected_language = data.get('language', 'python')
    
    if not code.strip():
        await message.answer("–ö–æ–¥ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –û—Ç–ø—Ä–∞–≤—å –∫–æ–¥ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏.")
        return
    
    # –û–ü–†–ï–î–ï–õ–Ø–ï–ú –†–ï–ê–õ–¨–ù–´–ô –Ø–ó–´–ö –ö–û–î–ê
    detected_language = detect_language(code)
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–≤–ø–∞–¥–∞–µ—Ç –ª–∏ –≤—ã–±—Ä–∞–Ω–Ω—ã–π —è–∑—ã–∫ —Å —Ä–µ–∞–ª—å–Ω—ã–º
    if detected_language != selected_language and detected_language != 'unknown':
        await message.answer(
            f"‚ùå *–ù–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —è–∑—ã–∫–∞!*\n\n"
            f"–¢—ã –≤—ã–±—Ä–∞–ª —è–∑—ã–∫: *{selected_language.capitalize()}*\n"
            f"–ù–æ –æ—Ç–ø—Ä–∞–≤–∏–ª –∫–æ–¥ –Ω–∞ —è–∑—ã–∫–µ: *{detected_language.capitalize()}*\n\n"
            f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —è–∑—ã–∫ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å –∫–æ–¥ –Ω–∞ {selected_language.capitalize()}.",
            parse_mode="Markdown"
        )
        return
    
    # –ò—â–µ–º –∑–∞–¥–∞—á—É
    task = None
    if selected_language in TASKS:
        for category in TASKS[selected_language]:
            for t in TASKS[selected_language][category]:
                if t['id'] == task_id:
                    task = t
                    break
    
    if not task:
        await message.answer("‚ùå –ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
        await state.clear()
        return
    
    status_msg = await message.answer(f"üîç –ü—Ä–æ–≤–µ—Ä—è—é –∫–æ–¥ –Ω–∞ {selected_language.capitalize()}...")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–¥
    if selected_language == 'python':
        result = CodeChecker.check_python(code, task['function_name'], task['test_cases'])
    elif selected_language == 'javascript':
        if not shutil.which('node'):
            await status_msg.delete()
            await message.answer(
                "‚ùå *Node.js –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω*\n\n"
                "–î–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ JavaScript –∫–æ–¥–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è Node.js.\n"
                "–°–∫–∞—á–∞–π –∏ —É—Å—Ç–∞–Ω–æ–≤–∏ —Å [nodejs.org](https://nodejs.org/)",
                parse_mode="Markdown",
                disable_web_page_preview=True
            )
            return
        result = CodeChecker.check_javascript(code, task['function_name'], task['test_cases'])
    elif selected_language == 'java':
        if not shutil.which('javac') or not shutil.which('java'):
            await status_msg.delete()
            await message.answer(
                "‚ùå *JDK –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω*\n\n"
                "–î–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ Java –∫–æ–¥–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è Java Development Kit.\n"
                "–°–∫–∞—á–∞–π –∏ —É—Å—Ç–∞–Ω–æ–≤–∏ —Å [oracle.com](https://www.oracle.com/java/technologies/downloads/)",
                parse_mode="Markdown",
                disable_web_page_preview=True
            )
            return
        result = CodeChecker.check_java(code, task['function_name'], task['test_cases'])
    else:
        result = {'error': f'–Ø–∑—ã–∫ {selected_language} –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è'}
    
    await status_msg.delete()
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
    response = format_result_message(result, selected_language, task)
    
    # –ö–Ω–æ–ø–∫–∏ –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è
    builder = InlineKeyboardBuilder()
    builder.add(InlineKeyboardButton(text="üìù –î—Ä—É–≥–∏–µ –∑–∞–¥–∞—á–∏", callback_data="back_to_categories"))
    builder.add(InlineKeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main"))
    builder.adjust(1)
    
    await message.answer(response, parse_mode="Markdown", reply_markup=builder.as_markup())
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ø—ã—Ç–∫—É
    if 'passed_count' in result and 'total_count' in result:
        save_task_attempt(
            message.from_user.id,
            task_id,
            code[:500],
            result['passed_count'],
            result['total_count']
        )

@dp.message()
async def handle_unknown(message: Message, state: FSMContext):
    current_state = await state.get_state()
    
    if current_state is None:
        await message.answer(
            "–Ø –Ω–µ –ø–æ–Ω–∏–º–∞—é —ç—Ç—É –∫–æ–º–∞–Ω–¥—É. –ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ:",
            reply_markup=get_main_keyboard()
        )
    else:
        await message.answer(
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏!",
            reply_markup=get_main_keyboard()
        )

# ========== –ó–ê–ü–£–°–ö –ë–û–¢–ê ==========
async def main():
    await dp.start_polling(bot, skip_updates=True)

if __name__ == '__main__':
    asyncio.run(main())
